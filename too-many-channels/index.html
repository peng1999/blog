<!DOCTYPE html>
<html lang="en">
    <head>
      
      <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-EC6VKH78QR"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-EC6VKH78QR');
        </script>
      
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
      
      <meta name='description' content='Channel 是异步编程 CSP 模型和 Actor 模型的重要组成部分，是一种用于消息同步的数据结构。Go 语言中的 chan 类型即是一种 channel 的实现。在使用 Rust 进行异步编程的时候也需要使用 channel。然而 Rust 中的 channel 似乎太多了。
'>
      
    

      <title>pg999w&#x27;s blog - Too many channels in Rust but only one in Go</title>

      
          
          <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.pg999w.top/rss.xml">
          
      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js" integrity="sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy" crossorigin="anonymous"></script>
              
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
                  onload="renderMathInElement(document.body);"></script>
              
          
      

      
    <link rel="stylesheet" href="https://blog.pg999w.top/site.css">
<link rel="stylesheet" href="https://blog.pg999w.top/custom.css">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100..900&family=Noto+Serif+Display:ital,wght@0,100..900;1,100..900&family=Noto+Serif+SC:wght@400;500;700&family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&display=swap" rel="stylesheet">




      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;" class="logo">pg999w’s blog</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;&#x2F;rss.xml">
                            RSS
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;&#x2F;about">
                            About
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;">pg999w’s blog</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;&#x2F;rss.xml">
                                    RSS
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;&#x2F;tags">
                                    Tags
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;&#x2F;about">
                                    About
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://blog.pg999w.top/too-many-channels/#go-and-rendezvous" class="toc-link">Go and rendezvous</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.pg999w.top/too-many-channels/#can-the-sender-awaits" class="toc-link">Can the sender awaits?</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.pg999w.top/too-many-channels/#to-be-cloneable-or-not-to-be-cloneable" class="toc-link">To be cloneable or not to be cloneable</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.pg999w.top/too-many-channels/#mix-all-together" class="toc-link">Mix all together</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.pg999w.top/too-many-channels/#epilogue" class="toc-link">Epilogue</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.pg999w.top/too-many-channels/#footnotes" class="toc-link">Footnotes</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;too-many-channels&#x2F;">Too many channels in Rust but only one in Go</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2022-03-24</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>Channel 是异步编程 CSP 模型<sup class="footnote-reference"><a href="#csp">1</a></sup>和 Actor 模型的重要组成部分，是一种用于消息同步的数据结构。Go 语言中的 <code>chan</code> 类型即是一种 channel 的实现。在使用 Rust 进行异步编程的时候也需要使用 channel。然而 Rust 中的 channel 似乎太多了。</p>
<span id="continue-reading"></span><style type="text/css">
em, strong {
color: purple;
}
img {
display: block;
margin: 0 auto;
}
</style>
<p>首先 Rust 标准库 <code>std::sync::mpsc</code> 模块中就提供了两种 channel 实现 <code>channel</code> 和 <code>sync_channel</code>。最流行的 Rust 异步运行时 <a href="https://tokio.rs">tokio</a> 也在 <code>tokio::sync</code> 模块中提供了其自己的 channel 实现，有四种之多。如果我们访问 Lib.rs 上的 <a href="https://lib.rs/concurrency">Concurrency</a> 分类，我们能轻易找到排名第 2 和第 8 的两个专门的 channel 库 crossbeam-channel 和 flume。这两个库分别有上千和上百的公开 crate 依赖。既然在 Go 语言当中，一种 channel 就够了，那在 Rust 中我们为什么需要这么多 channel 呢？</p>
<h2 id="go-and-rendezvous">Go and rendezvous</h2>
<p>实际上，channel 不止一种。Go 语言里使用 <code>make(chan T)</code> 创建的是 <em>rendezvous channel</em>，内部不使用缓冲区。如果通过一个 rendezvous channel 从一个 goroutine 向另一个 goroutine 发送消息，则会一直阻塞，直到对方接收为止。如果我们希望发送数据的 goroutine 不要阻塞，那么可以使用 <code>make(chan T, size)</code> 创建一个 <em>buffered channel</em>，这时将会创建一个大小为 <code>size</code> 的缓冲区。只要缓冲区不满，发送者就不必阻塞。</p>
<p>在 Go 语言中，并不需要有意避免阻塞一个 goroutine，调度器将会把当前的 CPU 资源分给其他可以继续执行的 goroutine。所以大多数时候简单的 rendezvous channel 就足够用了。但是如果由于种种原因，我们真的需要 channel 永远不要阻塞，这时即使是固定大小的 buffered channel 也不能满足要求，我们需要一个能自动扩容缓冲区的 <em>unbounded buffered channel</em>。Go 内置的 <code>chan</code> 类型没有提供这样的功能，好在我们可以将两个 renderzvous channel 和一个可扩容的环状缓冲区组合起来，实现一个 unbounded buffer。<a href="https://github.com/smallnest/chanx">chanx</a> 就是这样的一个实现<sup class="footnote-reference"><a href="#chanx">1</a></sup>。</p>
<p><img src="https://blog.pg999w.top/too-many-channels/rendezvous.drawio.svg" alt="rendezvous" /></p>
<p>查看 chanx 的源代码我们可以看到，其内部使用了两个 <code>chan</code>，并为每个 channel 都创建了一个新的 goroutine。这显然带来了不必要的开销。用一种 channel 来实现其他类型的 channel，这当然符合 Go 语言极简主义的哲学，然而其付出的性能代价是 Rust 所不能接受的。所以我们看到 Rust 标准库除了提供类似于 Go <code>chan</code> 的 <code>mpsc::sync_channel</code>，还另外实现了 unbounded channel 即 <code>mpsc::channel</code>。其他 Rust 库的 channel 也基本都提供了 bounded 和 unbounded 变体。</p>
<p>值得注意的是在 Go 语言当中 rendezvous channel 常常和 select 语句搭配使用，而 Rust 标准库中的 <code>select!</code> 宏由于种种原因已经<a href="https://github.com/rust-lang/rust/pull/60921">被移除了</a>。好在第三方库的 channel 都实现了 <code>select!</code> 宏，想要在 Rust 中像 Go 一样用 rendezvous channel 和 select 编写程序的话，使用第三方库即可。</p>
<h2 id="can-the-sender-awaits">Can the sender awaits?</h2>
<p>缓冲区的问题归根结底还是发送端 send 函数阻塞的问题。基本上我们有「unbounded channel —— 不阻塞线程；bounded channel —— 可能阻塞线程」这样一组对应关系。为了像 Go 语言一样即使没有缓冲区也不阻塞线程，我们需要利用 Rust 的 async 机制。支持 async 异步的 channel 将包含一个 <code>async fn send(T)</code> 和 <code>async fn recv()</code>，调用时只会阻塞当前 task 而不会影响其他任务。</p>
<p>与 Go 语言不同，Rust 的 async 函数是所谓的「着色函数」，这意味这不能在非 async 环境中调用 async 函数。同时，基于 async 运行时的实现原理，也不能在 async 环境中直接调用同步的阻塞函数。这样实际上可以把函数分成三种类型：非阻塞函数（unblocked）、同步的阻塞函数（blocked）、以及 async 函数。他们的特性可以总结如下：</p>
<table><thead><tr><th></th><th>可以用在非 asnyc 环境</th><th>可以用在 async 环境</th></tr></thead><tbody>
<tr><td>不会阻塞</td><td>unblocked</td><td>unblocked</td></tr>
<tr><td>可能阻塞</td><td>blocked</td><td>async</td></tr>
</tbody></table>
<p>不同的 channel 实现，其 <code>send</code> 和 <code>recv</code> 函数具有的阻塞性质可能会不同。我们需要根据需求选取。如果 channel 一边实现了 async 函数，另一边实现了非 async 函数，我们就可以利用该 channel 在没有锁的情况下实现 async 程序部分与非 async 部分的同步。</p>
<h2 id="to-be-cloneable-or-not-to-be-cloneable">To be cloneable or not to be cloneable</h2>
<p>一个典型的 Rust channel 会被这样创建：</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let </span><span>(tx, rx): (Sender, Receiver) = </span><span style="color:#96b5b4;">channel</span><span>();
</span></code></pre>
<p>Sender 和 Receiver 在同一个线程被分别创建，然后再发到各自的线程执行工作。Rust 在语言层面上保证了多线程安全，在其中遇见多线程环境下使用的类型，自然会想要考察这两个对象相关的特性：</p>
<ol>
<li>它是否可以穿过线程边界？</li>
<li>它是否能够被多个线程无锁地共享？</li>
<li>它是否可以被低代价地克隆？</li>
</ol>
<p>对于第 1 个问题，简单地检查类型是否满足 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> 约束即可。答案显然是肯定的。作为 Rust 多线程安全的基石之一，绝大多数类型都实现了 <code>Send</code>。各 channel 库中的 Sender 和 Receiver 也不例外。<sup class="footnote-reference"><a href="#mutex-sync">2</a></sup></p>
<p>而第 2 个问题则没有看起来的那么简单。虽然 Rust 中有 <code>Sync</code> 这个 trait，而且和 <code>Send</code> 一样，绝大多数类型也实现了 <code>Sync</code>，但是 <code>T: Sync</code> 只意味着<strong>不可变</strong>的 <code>&amp;T</code> 能被多个线程共享。如果某个 Sender 的 send 函数或 Receiver 的 recv 函数要求拿到一个 <code>&amp;mut self</code>，仅仅<strong>不可变</strong>的共享则完全没有意义。所以，要想肯定地回答问题 2，需要同时满足两个条件：所考察对象满足 <code>Sync</code> 约束；其 send / recv 函数只要求不可变的 <code>&amp;self</code> 引用。<code>std::sync::mpsc::Receiver</code> 即不满足前一个条件，而 <code>tokio::sync::mpsc::Receiver</code> 则不满足后一个条件。</p>
<p>即使对象能够以 <code>&amp;T</code> 的形式在多个线程中无锁共享，在多数情况下，为了解决生命周期的问题，我们仍然需要在外面套上 <code>Arc</code> 才能达到目的。</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let </span><span>(tx, rx) = </span><span style="color:#96b5b4;">channel</span><span>();
</span><span style="color:#b48ead;">let</span><span> tx_arc = Arc::new(tx);
</span><span style="color:#b48ead;">let</span><span> tx_clone = tx_arc.</span><span style="color:#96b5b4;">clone</span><span>();
</span><span>std::process::spawn(|| tx_clone.</span><span style="color:#96b5b4;">send</span><span>(</span><span style="color:#96b5b4;">something</span><span>()));
</span></code></pre>
<p>这时自然会想到，如果 <code>tx</code> 自身能够 <code>clone</code>，那么我们就不必再套一个 <code>Arc</code> 了。这正是我们要考察的第 3 个特性。如果 Sender 实现了 <code>Clone</code> 约束，我们可以直接通过克隆来在多个线程之间分享：</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let </span><span>(tx, rx) = </span><span style="color:#96b5b4;">channel</span><span>();
</span><span style="color:#b48ead;">let</span><span> tx_clone = tx.</span><span style="color:#96b5b4;">clone</span><span>();
</span><span>std::process::spawn(|| tx_clone.</span><span style="color:#96b5b4;">send</span><span>(</span><span style="color:#96b5b4;">something</span><span>()));
</span></code></pre>
<p>虽然性质 2 和性质 3 并不全等，然而实现了性质 2 的 channel 类型实际上也都实现了性质 3。一般而言，在考察 channel 类型的线程同步特性时，只需要考察它是否实现 <code>Clone</code> 即可。</p>
<p>回过头来考察 Go 语言的 channel，我们发现其 <code>chan</code> 类型既可以做 Sender，也可以做 Receiver。<code>chan</code> 也可以安全地被克隆，在多个线程中共享。这实际上一个 MPMC channel<sup class="footnote-reference"><a href="#mpmc">3</a></sup>。而在 Rust 中，通过限制 <code>Receiver: !Clone</code>，我们可以得到一个 MPSC channel。注意虽然 MPMC channel 有多个出口，但任意的消息只能从其中一个出口出去。如果我们需要一个「广播」性质的 channel，我们可以实现一个 MPSC channel 数组，每个消息分别向各个出口发送，也可以直接使用 <code>tokio::sync::broadcast</code> 中的 channel。</p>
<p><img src="https://blog.pg999w.top/too-many-channels/broadcast.drawio.svg" alt="broadcast" /></p>
<h2 id="mix-all-together">Mix all together</h2>
<p>前面讨论了缓冲区大小、<code>send</code> / <code>recv</code> 函数的阻塞性、以及 <code>Clone</code> trait。在不同的场合下，我们需要选取具有不同特性组合的 channel。现在是时候画一张大表把它们全部列出来了。</p>
<table>
<thead>
  <tr>
    <th colspan="2"> Channel constructor </th>
    <th>Buffer size </th>
    <th>Cloneable </th>
    <th>send </th>
    <th>recv </th>
  </tr>
</thead>
<tbody>
  <tr>
    <td rowspan="2">std::mpsc <br> </td>
    <td>channel </td>
    <td>∞ </td>
    <td>Sender </td>
    <td>unblocked </td>
    <td>blocked </td>
  </tr>
  <tr>
    <td>sync_channel </td>
    <td>0~n </td>
    <td>Sender </td>
    <td>blocked </td>
    <td>blocked </td>
  </tr>
  <tr>
    <td rowspan="2">crossbeam-channel <br> </td>
    <td>unbounded <br> </td>
    <td>∞ <br> </td>
    <td>Sender, Receiver <br> </td>
    <td>unblocked <br> </td>
    <td>blocked </td>
  </tr>
  <tr>
    <td>bounded </td>
    <td>0~n </td>
    <td>Sender, Receiver </td>
    <td>blocked </td>
    <td>blocked </td>
  </tr>
  <tr>
    <td rowspan="3">tokio::sync <br> </td>
    <td>mpsc::unbounded_channel </td>
    <td>∞ <br> </td>
    <td>Sender </td>
    <td>unblocked </td>
    <td>async </td>
  </tr>
  <tr>
    <td>mpsc::channel </td>
    <td>1~n </td>
    <td>Sender </td>
    <td>async </td>
    <td>async </td>
  </tr>
  <tr>
    <td>broadcast </td>
    <td>1~n </td>
    <td>Sender </td>
    <td>unblocked </td>
    <td>async </td>
  </tr>
  <tr>
    <td rowspan="2">flume </td>
    <td>unbounded <br> </td>
    <td>∞ <br> </td>
    <td>Sender, Receiver <br> </td>
    <td>unblocked <br> </td>
    <td>blocked/async </td>
  </tr>
  <tr>
    <td>bounded </td>
    <td>0~n </td>
    <td>Sender, Receiver </td>
    <td>blocked/async </td>
    <td>blocked/async </td>
  </tr>
</tbody>
</table>
<p><code>recv</code> 不可能做到完全不阻塞，但是 Receiver 一般都提供一个不阻塞的 <code>try_recv</code> 函数。</p>
<p><code>tokio::sync::broadcast</code> 里的 Receiver 虽然不能 clone，但是可以直接通过 <code>Sender::subscribe</code> 得到。</p>
<h2 id="epilogue">Epilogue</h2>
<p>本文所讨论的 channel 概念源自异步编程模型 CSP 和 Actor，这两种模型都是语言无关的数学抽象。我们看到同样的概念可以同时用在不同的语言之中。在这样的基础上，Go 语言中基于 CSP 的异步编程模型可以直接迁移到 Rust 当中去。虽然这两种语言各自具有鲜明的特点，Go 语言奉行极简主义，而 Rust 则拥抱复杂性以换取安全和更好的性能，但一个熟悉 Go 异步编程的程序员，应当发现能用同样的心智模型在 Rust 编写异步程序。</p>
<h2 id="footnotes">Footnotes</h2>
<div class="footnote-definition" id="csp"><sup class="footnote-definition-label">4</sup>
<p>Communicating Sequential Processes，交谈循序程序，又译为通信顺序进程、交换消息的循序程序</p>
</div>
<div class="footnote-definition" id="chanx"><sup class="footnote-definition-label">1</sup>
<p>实际上 chanx 使用了一定大小的 channel buffer，不过如果移除这个 buffer，程序仍然能正常工作。</p>
</div>
<div class="footnote-definition" id="mutex-sync"><sup class="footnote-definition-label">2</sup>
<p><code>T: !Send</code> 的类型在多线程环境中寸步难行。注意到 <code>std::sync::Mutex</code> 的 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Send"><code>Send</code> 和 <code>Sync</code> 实现</a>：</p>
</div>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl</span><span>&lt;T: </span><span style="background-color:#bf616a;color:#eff1f5;">?</span><span>Sized + Send&gt; Send for Mutex&lt;T&gt; {}
</span><span style="color:#b48ead;">impl</span><span>&lt;T: </span><span style="background-color:#bf616a;color:#eff1f5;">?</span><span>Sized + Send&gt; Sync for Mutex&lt;T&gt; {}
</span></code></pre>
<p>如果一个类型 <code>T: !Send</code>，我们甚至没法通过加锁实现跨线程共享。</p>
<div class="footnote-definition" id="mpmc"><sup class="footnote-definition-label">3</sup>
<p>Multiple producer multiple consumer.</p>
</div>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://blog.pg999w.top/tags/programming/">#programming</a>
                    
                        <a href="https://blog.pg999w.top/tags/go/">#go</a>
                    
                        <a href="https://blog.pg999w.top/tags/rust/">#rust</a>
                    
                </div>
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;nix-smartcross&#x2F;">‹ 用 Nix 管理交叉编译 Rust 项目的环境</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;movie-2021&#x2F;">2021 个人年度电影 ›</a>
                    
                </div>
            

        

    </div>

    
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<hr />
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
    <img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
</a>
<br />
<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Too many channels in Rust but only one in Go</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https:&#x2F;&#x2F;blog.pg999w.top&#x2F;too-many-channels&#x2F;" property="cc:attributionName" rel="cc:attributionURL">Peng Guanwen</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。

<br />

<span id="busuanzi_container_site_uv" style="display:none">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>
<span id="busuanzi_container_page_pv" style="display:none">
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>


</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://blog.pg999w.top/even.js" ></script>
      
    </body>

</html>
